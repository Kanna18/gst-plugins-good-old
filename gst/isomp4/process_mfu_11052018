/*
 * ISOBMFF PARSER
 * MOHAMMED SAFWAN SADA
 *
 * */


#include <stdio.h>
#include <string.h>
#include "pthread.h"
#include "MMTPacket.h"
#include "atoms.h"
#include "qtdemux.h"
#include "parser.h"
#include "MMTBitstream.h"

#define ASSET_LENGTH 16
#define BUF_SIZE 4000
//mfu_box mfu_b;
//struct MMTHSample mmthsample;

void process_mfus(GstQTDemux * qtdemux, unsigned char* data, int size, int mediaType)
{
   //char cmd[128];
   //FILE *fp = NULL;
   int i, offset, mfu_offset, ret, is_muli;
   static int need_data[2], sample_size[2];
   static guint64 sample_offset[2];
   static unsigned int rem_size[2];
   GstBuffer *mfu_buf, *out;
	 mfu_buf = out = NULL;
  //QtDemuxStream *stream;
   is_muli = offset = mfu_offset = ret = 0;
#if 0
   if(mediaType == 1)
      sprintf(cmd, "video.data");
   else
      sprintf(cmd, "audio.data");
   fp = fopen(cmd, "a");
#endif
	qtdemux->mfu_offset = 0;
   for(i = 0; i < size; ++i)
   {
      if(memcmp(data+i,"muli",4) == 0)
		{
			is_muli = 1;
#if 0
		   if(qtdemux->mmdatbuffer[mediaType])
				gst_buffer_unref (qtdemux->mmdatbuffer[mediaType]);
#endif
			mfu_offset = i+Read32(data+(i-4))-4;
			qtdemux->mfu_offset = mfu_offset;
			rem_size[mediaType] = size - mfu_offset;
			offset = i- 27;
			parse_mfu(data+offset, rem_size[mediaType]);
			qtdemux->mfu_size = mfu_b.length;
			if(rem_size[mediaType] >= mfu_b.length) 
				need_data[mediaType] = 0;
			else
			{
				sample_size[mediaType] = mfu_b.length;
				sample_offset[mediaType] = mfu_b.offset;
				need_data[mediaType] = 1;
			}

			//break;
		}
   }
#if 0
  //QtDemuxStream *stream;
	 //stream = qtdemux->streams[mediaType];
	 //GST_DEBUG_OBJECT (qtdemux,"SPPPPPPPPPPad:%s needdata %d" , GST_PAD_NAME (stream->pad), need_data);
    //gst_pad_push (stream->pad, data+mfu_offset);

#else
	 GST_DEBUG_OBJECT(qtdemux, "sample_offset:%"G_GUINT64_FORMAT, sample_offset[mediaType]);
	 if(is_muli)
	 {
		  mfu_buf = gst_buffer_new_and_alloc (rem_size[mediaType]); 
		  gst_buffer_fill (mfu_buf, 0, data+mfu_offset, rem_size[mediaType]);
	 }
	 else
	 {
		  mfu_buf = gst_buffer_new_and_alloc (size); 
		  gst_buffer_fill (mfu_buf, 0, data+mfu_offset, size);
	 }
	 if(need_data[mediaType])
	 {
#if 0
		 if(qtdemux->mmdatbuffer[mediaType])
		 {
		    GST_DEBUG_OBJECT(qtdemux, "SSSSSHHHHH append buf to mmdat");
			 qtdemux->mmdatbuffer[mediaType] = gst_buffer_append (qtdemux->mmdatbuffer[mediaType], mfu_buf);
		 }
		 else
		 {
		    GST_DEBUG_OBJECT(qtdemux, "SSSSSHHHHH assign buf to mmdat");
			 qtdemux->mmdatbuffer[mediaType] = mfu_buf;
		 }
#else
		 if(qtdemux->mdatbuffer)
		 {
		    GST_DEBUG_OBJECT(qtdemux, "SSSSSHHHHH append buf to mmdat");
		   if(GST_IS_BUFFER (qtdemux->mdatbuffer))
				GST_DEBUG_OBJECT(qtdemux, "SUCCESS ISBUFFER SSSSSHHHHH append buf to mmdat");
	      else
				GST_DEBUG_OBJECT(qtdemux, "FAILED ISBUFFER SSSSSHHHHH append buf to mmdat");
			 out = gst_buffer_append (qtdemux->mdatbuffer, mfu_buf);
		    qtdemux->mdatbuffer = out;
		 }
		 else
		 {
		    GST_DEBUG_OBJECT(qtdemux, "SSSSSHHHHH assign buf to mmdat");
			 qtdemux->mdatbuffer= mfu_buf;
		 }
#endif
		 if(!is_muli)
			 rem_size[mediaType] +=size;	 
		 if(rem_size[mediaType] >= sample_size[mediaType])
		 {
		  //gst_qtdemux_loop_state_movie (qtdemux);
			 gst_mmtdemux_state_movie(qtdemux, sample_offset[mediaType] );
			 need_data[mediaType] = 0;
#if 0
			 gst_buffer_unref (qtdemux->mmdatbuffer[mediaType]);
			 qtdemux->mmdatbuffer[mediaType] = NULL;
#else
			 gst_buffer_unref (qtdemux->mdatbuffer);
			 qtdemux->mdatbuffer = NULL;
#endif
		 }
	 }
	 else if (is_muli || rem_size[mediaType] >= mfu_b.length)
	 {
		 //qtdemux->mmdatbuffer[mediaType] = mfu_buf;
		 gst_mmtdemux_state_movie(qtdemux, (guint64 )mfu_b.offset);
		  gst_qtdemux_loop_state_movie (qtdemux);
		 //gst_buffer_unref (qtdemux->mmdatbuffer[mediaType]);
		 //qtdemux->mmdatbuffer[mediaType] = NULL;

		 //gst_qtdemux_decorate_and_push_buffer (qtdemux, stream, buf, dts, pts, duration, keyframe, min_time, offset);

	 }
		 GST_DEBUG_OBJECT (qtdemux,"SIZEEEE %d :: mfu_b.length: %d" , rem_size[mediaType], mfu_b.length);
	gst_buffer_unref (mfu_buf);
	 //stream = qtdemux->streams[mediaType];
#endif
#if 0
		 ret = gst_qtdemux_loop_state_movie (qtdemux);
		 if (qtdemux->segment.rate < 0 && ret == GST_FLOW_EOS) {
			 ret = gst_qtdemux_seek_to_previous_keyframe (qtdemux);
		 }
#endif
	 
		//gst_buffer_append (qtdemux->mdatbuffer, data+mfu_offset);
  // fclose(fp);
}


void parse_mfu(unsigned char *data, int length)
{
	unsigned char byte8;
	unsigned short byte16;
	unsigned int byte32;
	//mfu_box mfu_b;
	mfu_b.sequence_number = Read32(data);
	mfu_b.trackrefindex = Read8(data+4);
	mfu_b.movie_fragment_sequence_number = Read32(data+5);
	mfu_b.samplenumber = Read32(data+9);
	mfu_b.priority = Read8(data+13);
	mfu_b.dependency_counter = Read8(data+14);
	mfu_b.offset = Read32(data+15);
	mfu_b.length = Read32(data+19);

	GST_DEBUG_OBJECT(NULL,"KKK sequence_number: %u, trackrefindex: %u, movie_fragment_sequence_number: %u, samplenumber: %u, priority: %u, dependency_counter: %u, offset: %u, length: %u\n\n", mfu_b.sequence_number, mfu_b.trackrefindex, mfu_b.movie_fragment_sequence_number, mfu_b.samplenumber, mfu_b.priority, mfu_b.dependency_counter, mfu_b.offset, mfu_b.length);

	//fprintf(fp,"mfu sequence_number: %d, ",mfu_b.movie_fragment_sequence_number);
	//fprintf(fp,"trackrefIndex: %d, ",mfu_b.trackrefindex);
	//fprintf(fp,"samplenumber: %d, ",mfu_b.samplenumber);
	//fprintf(fp,"offset: %d, ",mfu_b.offset);
	byte8 = Read8(data+23);
	mfu_b.mul_linfo.multilayer_flag = byte8 & 0x01;
	if(mfu_b.mul_linfo.multilayer_flag)
	{
	   byte32 = Read32(data+24);
		mfu_b.mul_linfo.dependency_id = byte32 & 0x07;
		mfu_b.mul_linfo.depth_flag = byte32 & 0x08;
		mfu_b.mul_linfo.temporal_id = byte32 & 0x0700;
		mfu_b.mul_linfo.quality_id = byte32 & 0xF000;
		byte16 = Read16(data+28);
		mfu_b.mul_linfo.priority_id =  byte16 & 0x3F;
		mfu_b.mul_linfo.view_id = byte16 & 0xFFC;
	}
   else
	{
		byte16 = Read16(data+24);
		mfu_b.mul_linfo.layer_id = byte16 & 0x3F;
		mfu_b.mul_linfo.temporal_id = byte16 & 0x1E0;
	}
}


int pullatom(unsigned char *data, char *buf)
{
    unsigned int length = 0;
	 int offset = 0;
    length = Read32(data);
    if(!length)
        return 0;
    offset += 4;
    memcpy(buf, data+offset, 4);
    GST_DEBUG_OBJECT(NULL,"\t length: %d, box: %s\n", length, buf);
    return length;
}

int process_init_data(GstQTDemux * qtdemux, unsigned char *buf,int size)
{
   int length;
   static unsigned char Data[4096];
   static int tempsize/*, once*/;
   static int offset = 0;
   char boxType[4] = {"0"};
   int localOffset;
   GST_DEBUG_OBJECT(NULL, "HHHHHHHHHH %s size: %d\n", __func__, size);
#if 0
   if(offset == 0)
      Data=(unsigned char*)malloc(sizeof(unsigned char)*size);
   else
      Data=(unsigned char*)realloc(Data, sizeof(unsigned char)*size);
#endif
   memcpy(Data+offset,buf,size);
   size += tempsize;
   tempsize = size;
   localOffset=0;
   while(localOffset<size)
   {
      length = pullatom(Data+localOffset, boxType);
      GST_DEBUG_OBJECT(NULL,"HYBZ lenght: %d....................available: %d TYPE: %s\n", length, size-localOffset, boxType);
      GST_DEBUG_OBJECT(NULL, "HYBZ lenght: %d....................available: %d TYPE: %s\n", length, size-localOffset, boxType);
      if(length > (size-localOffset) )
         goto DataInSufficient;  // 0  for insufficient data
      else if(length <= 0)
         goto reset_buf;  // 0  for insufficient data
      if(!strncmp(boxType,FTYP,4))
      {
  //       parse_ftyp(Data+localOffset+8);
	        qtdemux_parse_ftyp (qtdemux, Data+localOffset, length);
      }
      else if(!strncmp(boxType,MMPU,4))
      {
//         parse_mmpu(Data+localOffset+8);
		        qtdemux_parse_mmpu (qtdemux, Data+localOffset, length);

      }
      else if(!strncmp(boxType,MOOV,4))
      {
      //   parse_moov(Data+localOffset+8,length);
		  if(1/*!once*/)
		  {
			  qtdemux_parse_moov (qtdemux, Data+localOffset, length);
			  qtdemux_parse_tree(qtdemux);
		//	  if(qtdemux->mediaType == 2)
				  //once = 1;
		  }
				//qtdemux->got_moov = TRUE;
	//			qtdemux->moov_detected = 1;
				
      }
      localOffset+=length;
   }
reset_buf:
   tempsize = 0;
   offset = 0;
   return 1;
DataInSufficient:
   GST_DEBUG_OBJECT(NULL,"MOSS: Insufficient data required length: %d available: %d\n", length, size);
   offset+=size;
   return 0;
}

int GainMMTdemux(GstQTDemux * qtdemux, unsigned char *buf,int size,int DataType, int mediaType)
{
	 static short once;
	 GST_DEBUG_OBJECT(NULL,"GAIANMMTDEMUX.................. DataType: %d\n", DataType);
   GST_DEBUG_OBJECT(NULL, "HHHHHHHHHH %s size: %d DataType: %d, mediaType:%s\n", __func__, size, DataType, mediaType==1?"audio":"video");
	switch(DataType)
	{
		case 00:
			{
			//	if(mediaType == 1)
				//	 gst_qtdemux_reset_stream(qtdemux);
				GST_DEBUG_OBJECT(NULL, "IIIIIIIII %s size: %d\n", __func__, size);
				process_init_data(qtdemux, buf, size);
				break;
			}
		case 01:
			{
				//process_moof(buf, size);
				qtdemux_parse_moof (qtdemux, buf, size, qtdemux->moof_offset, NULL);
				if(!once && (mediaType == 1))
				{
					// qtdemux->stream_n = mediaType;
					 qtdemux_prepare_streams (qtdemux);
					 qtdemux_expose_streams (qtdemux);
					 once = !once;
				}
				break;
			}
		case 02:
			{
				//TODO: Need to be implemented, As this is just for cross check mfu header and mfu samples for Audio
				//fp = fopen("isobmff.csv", "a");
				 process_mfus(qtdemux, buf, size, mediaType);
#if 0
				char boxType[4];
   GST_DEBUG_OBJECT(NULL, "JJJJJJJJJJJJJJ %s size: %d\n", __func__, size);
				pullatom(buf+37, boxType);
				if(!memcmp(boxType, "muli", 4))
				{
				   GST_DEBUG_OBJECT(NULL,"MMTH SAMPLE PRESENT\n");
					parse_mfu(buf+14, size);
				}
				//gst_buffer_append (qtdemux->mdatbuffer, buf+)
				//FILE *fp = fopen("isobmff.csv", "a");
				//GST_DEBUG_OBJECT(NULL,"mmthsample offset: %d, mmthsample length: %d\n", mmthsample.offset, mmthsample.length);
				fprintf(fp,"mmthsample offset: %d, ",mmthsample.offset);
				fprintf(fp,"mmthsample length: %d \n ",mmthsample.length);

				//fwrite(buf, 1, size, fp);
				//fwrite("===================", 1, sizeof("==================="), fp);
				fclose(fp);
#endif
				break;
			}
	}
	 return 1;
}
